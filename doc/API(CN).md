# Rift Rail - 模组兼容性与API指南

欢迎！本文档旨在帮助其他模组开发者与 Rift Rail 进行兼容。

## 核心机制：销毁与再创造

理解 Rift Rail 的核心机制至关重要：当一列火车通过传送门时，它并非被“移动”，而是**旧的列车实体被逐节销毁，新的列车实体在出口被逐节重新创建**。

这意味着，任何直接引用旧列车实体（`LuaEntity`）的变量或数据表，在传送后都会失效。

## 如何追踪传送后的列车 (重要！)

为了在特定场景下最大化性能，Rift Rail 会根据传送门的角度，采用两种不同的方式创建新列车。这导致它会触发两种不同的事件。

**为了确保100%兼容，您的模组必须同时监听以下两个事件：**

1.  `defines.events.on_built_entity`
    *   当传送需要复杂转向时，Rift Rail 会使用 `create_entity` 方法，这会触发此标准建造事件。

2.  `defines.events.on_entity_cloned`
    *   当传送是简单的“掉头返回”（入口与出口朝向相反）时，Rift Rail 会使用高性能的 `clone` 方法，这会触发此克隆事件。

### 推荐的事件处理方式

最稳妥的方法是创建一个统一的处理函数，然后让两个事件都去调用它。

通过同时监听这两个事件，您的模组可以可靠地捕获所有由 Rift Rail 传送的列车，并与之进行交互。

如有任何问题，欢迎在我们的模组页面上提出。